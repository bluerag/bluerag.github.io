import{_ as d}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o,c as i,a as e,b as a,d as n,f as r}from"./app-5b62da0d.js";const p={},c=r('<p>功能详情...</p><h1 id="前端" tabindex="-1"><a class="header-anchor" href="#前端" aria-hidden="true">#</a> 前端</h1><h2 id="typescript" tabindex="-1"><a class="header-anchor" href="#typescript" aria-hidden="true">#</a> TypeScript</h2><h3 id="工具类型" tabindex="-1"><a class="header-anchor" href="#工具类型" aria-hidden="true">#</a> 工具类型</h3><h4 id="omit" tabindex="-1"><a class="header-anchor" href="#omit" aria-hidden="true">#</a> Omit</h4><p>Omit&lt;Type, Keys&gt;</p>',6),l=e("br",null,null,-1),h={href:"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-5.html#the-omit-helper-type",target:"_blank",rel:"noopener noreferrer"},u=e("code",null,"Type",-1),k=e("code",null,"Keys",-1),v={href:"https://www.typescriptlang.org/docs/handbook/utility-types.html#picktype-keys",target:"_blank",rel:"noopener noreferrer"},m=e("code",null,"Pick",-1),b=r(`<p>用于构造一个类型，忽略Type中的keys属性</p><h3 id="类型断言" tabindex="-1"><a class="header-anchor" href="#类型断言" aria-hidden="true">#</a> 类型断言</h3><h4 id="as" tabindex="-1"><a class="header-anchor" href="#as" aria-hidden="true">#</a> AS</h4><p>类型断言，手动指定一个值的类型</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code>值 <span class="token keyword">as</span> 类型  
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>或</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token operator">&lt;</span>类型<span class="token operator">&gt;</span>值
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>将一个联合类型断言为其中一个类型。</strong></p><p><strong>将一个父类断言为更加具体的子类。</strong></p><p><strong>将任何一个类型断言为 <code>any</code></strong>。</p><p><strong>将 <code>any</code> 断言为一个具体的类型。</strong></p><p><strong>as 可以将父类赋给子类，也可以把子类赋给父类，父类兼容子类时，它们可以相互进行类型断言</strong>。</p><h5 id="双重断言" tabindex="-1"><a class="header-anchor" href="#双重断言" aria-hidden="true">#</a> 双重断言</h5><p>可以将任何类型断言为any再将其断言为另一个不兼容的类型，比如<code>as any as type</code>通常来说,这是错误的做法。（兼容：A是B的子集，B兼容A）。</p><blockquote><p>类型断言只会影响 TypeScript 编译时的类型，类型断言语句在编译结果中会被删除。</p><p>类型断言不是类型转换，它不会真的影响到变量的类型。</p><p>若要进行类型转换，需要直接调用类型转换的方法。</p></blockquote><h4 id="extends" tabindex="-1"><a class="header-anchor" href="#extends" aria-hidden="true">#</a> extends</h4><p>用来扩展类型，子类型继承父类型</p><h3 id="类型" tabindex="-1"><a class="header-anchor" href="#类型" aria-hidden="true">#</a> 类型</h3><h4 id="空类型" tabindex="-1"><a class="header-anchor" href="#空类型" aria-hidden="true">#</a> 空类型</h4><h5 id="void" tabindex="-1"><a class="header-anchor" href="#void" aria-hidden="true">#</a> void</h5><p>空类型，与any相反。限制函数返回这为空时，函数可以直接return，不能return其他的结果。</p><p>把变量设置为void，这个变量只能接受undefined或null了。</p><h5 id="never" tabindex="-1"><a class="header-anchor" href="#never" aria-hidden="true">#</a> never</h5><p>代表<strong>永远不</strong>。button type，不兼容其他类型，只能赋值给另一个never。</p><p>用法：</p><p>函数返回类型为never时代表该函数永不返回，抛出异常的方法返回值就是never。</p><p>用来处理<code>switch case</code>或者<code>if else</code>所有的未处理类型 。</p><p>防止意外的 API 使用。</p><p>部分禁止结构类型。</p><p>限制函数参数。</p><h3 id="声明文件" tabindex="-1"><a class="header-anchor" href="#声明文件" aria-hidden="true">#</a> 声明文件</h3><p>声明文件,d.ts作为后缀,为了获得代码补全和类型检查而使用。声明文件只包含类型不包含实现。第三方库通常自带声明文件，若没有，可以自己写。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code>声明全局或局部变量：

<span class="token keyword">declare</span> <span class="token keyword">var</span><span class="token operator">/</span><span class="token keyword">let</span><span class="token operator">/</span><span class="token keyword">const</span> 声明变量<span class="token operator">/</span>常量
<span class="token keyword">declare</span> <span class="token keyword">function</span> 声明函数
<span class="token keyword">declare</span> <span class="token keyword">class</span> <span class="token class-name">声明</span> <span class="token keyword">class</span>
<span class="token class-name"><span class="token keyword">declare</span></span> <span class="token keyword">enum</span> 声明枚举变量
<span class="token keyword">declare</span> <span class="token keyword">namespace</span> <span class="token function">声明命名空间</span><span class="token punctuation">(</span>空间下必须有属性才生效<span class="token punctuation">)</span>
声明全局或局部类型：

<span class="token keyword">interface</span> <span class="token class-name">声明接口</span>
<span class="token keyword">type</span> <span class="token class-name">声明类型别名</span>
变量或类型的导入导出：

<span class="token keyword">export</span> 导出变量
<span class="token keyword">export</span> <span class="token keyword">namespace</span> 导出（含有子属性的）对象
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token constant">ES6</span> 默认导出
<span class="token keyword">export</span> <span class="token operator">=</span> commonjs 导出模块
<span class="token keyword">export</span> <span class="token keyword">as</span> <span class="token keyword">namespace</span> <span class="token constant">UMD</span> 库声明全局变量
扩展变量或模块：

<span class="token keyword">declare</span> global 在模块中声明全局变量或全局类型
<span class="token keyword">declare</span> <span class="token keyword">module</span> 声明模块或扩展模块
<span class="token comment">/// &lt;reference /&gt; 三斜线指令引用声明文件</span>
#声明各种变量
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一个声明文件中没有顶层的export或者import的时候，认为该文件是一个全局声明文件，在该文件内声明的变量或类型都是全局的，不需要import就可以在任何地方直接使用。</p><p>如果有export或import，则认为该文件是一个模块，要使用文件内声明的变量和类型，需要import对应的模块后再使用。</p><h4 id="declare-global" tabindex="-1"><a class="header-anchor" href="#declare-global" aria-hidden="true">#</a> declare global</h4><p>使用 <code>declare global</code> 可以在 npm 包或者 UMD 库的声明文件中扩展全局变量的类型。</p><p><code>declare global</code> 块中的声明就是全局的。</p><p><code>declare global</code> 块必须出现在模块声明文件中，才能有效声明全局变量或全局类型，也就是说在没有export或者import的情况下需要加上<code>export{}</code>才能生效。</p><h2 id="vue" tabindex="-1"><a class="header-anchor" href="#vue" aria-hidden="true">#</a> Vue</h2><h2 id="css" tabindex="-1"><a class="header-anchor" href="#css" aria-hidden="true">#</a> CSS</h2><h2 id="项目结构" tabindex="-1"><a class="header-anchor" href="#项目结构" aria-hidden="true">#</a> 项目结构</h2>`,42);function y(g,f){const s=t("ExternalLinkIcon");return o(),i("div",null,[c,e("blockquote",null,[e("p",null,[a("Released:"),l,e("a",h,[a("3.5"),n(s)])])]),e("p",null,[a("Constructs a type by picking all properties from "),u,a(" and then removing "),k,a(" (string literal or union of string literals). The opposite of "),e("a",v,[m,n(s)]),a(".")]),b])}const _=d(p,[["render",y],["__file","baz.html.vue"]]);export{_ as default};
